---
title: Best Practices
sidebar_position: 5
image: og/docs/concepts.jpg
# tags: ['concepts', 'search', 'optimization']
---

# 検索: ベストプラクティス

このページでは、検索の品質とパフォーマンスを最適化するための推奨ベストプラクティスを紹介します。

## フィルター

フィルターは、プロパティやメタデータに関連する特定の条件に基づいて検索結果を絞り込みます。

Weaviate では、フィルタリングを行う際に [事前フィルタリング](../filtering.md) を適用し、その結果を検索パラメーターとして渡します。これにより、フィルターが非常に制限的であってもリコールを高く保つことができます。

フィルタリング性能とディスク使用量のトレードオフのために、[各プロパティ用のインデックス](#index-types-and-filters) や [オプションのメタデータインデックス](#optional-metadata-filtering) を有効化または無効化できます。

### インデックス種別とフィルター

Weaviate は、フィルター処理を高速化するためにインデックスを利用します。

[Roaring bitmap インデックス (`indexFilterable`)](../filtering.md#indexfilterable) は `v1.18` で追加され、フィルタリング処理のパフォーマンスを向上させました。[範囲ベースインデックス (`indexRangeFilters`)](../filtering.md#indexrangefilters) は `v1.26` で追加され、`int`、`number`、`date` プロパティに対する範囲ベースの数値フィルタリングを高速化します。

これらのインデックスは、プロパティごとに [有効化または無効化](../../manage-collections/collection-operations.mdx#set-inverted-index-parameters) できます。

これらのインデックスを有効にすると検索は高速になりますが、ディスクおよびメモリの使用量がわずかに増加します。

経験則として、そのプロパティでフィルタリングが不要であることが確実でない限り、`indexFilterable` と `indexRangeFilters` の両方を有効にすることを推奨します。

### オプションメタデータのフィルタリング

プロパティ作成時に有効化しておけば、各プロパティは追加のメタデータフィルタリングを行うよう設定できます。

利用可能なオプションは次のとおりです:

- `indexTimestamps`: 作成時刻または最終更新時刻に基づくタイムスタンプフィルタリング用
- `indexNullState`: null 値によるフィルタリング用
- `indexPropertyLength`: テキストプロパティの長さによるフィルタリング用

これらのインデックスオプションを有効にすると、対応するフィルタリングが可能になりますが、ディスクおよびメモリの使用量がわずかに増加します。

## ベクトル検索

ベクトル検索は、クエリベクトルを保存済みのベクトルと比較し、最も近い一致を見つける類似度ベースの検索です。

Weaviate では、設定済みの [モデルプロバイダーインテグレーション](../../model-providers/index.md) を使用して、テキストや画像などのメディアをインポート時およびクエリ時に統合ベクトル化できます。

### ベクトライザーモデルの選択

ベクトル化は、データ（テキスト、画像など）をベクトライザーモデルによって数値ベクトルへ変換するプロセスです。

1. **埋め込みモデル**: Weaviate は、トランスフォーマーなどの機械学習モデルを使用して入力データをベクトル埋め込みへ変換します。  
2. **次元数**: ベクトルは複雑なセマンティック関係を表現するため、通常 768 や 1536 次元など高次元です。  
3. **セマンティック意味**: 高次元空間におけるベクトルの位置は、他のベクトルとのセマンティックな関係を表します。  

### 近似最近傍 (ANN) 検索

Weaviate のベクトル検索は、ANN アルゴリズムを用いて高次元空間内で類似ベクトルを効率的に検索します。

1. **厳密検索 vs. 近似検索**: 厳密な最近傍検索は最も近いベクトルを保証しますが、計算コストが高くなります。ANN はわずかな精度低下と引き換えに大幅な速度向上を実現します。  
2. **ANN アルゴリズム**: Weaviate は以下を含む複数の ANN アルゴリズムをサポートします:  
   - HNSW (Hierarchical Navigable Small World): 多層グラフ構造を作成し、効率的な検索を実現します。  
   - PQ (Product Quantization): ベクトルを圧縮してメモリ使用量を削減し、検索を高速化します。  
3. **インデックス構築**: Weaviate はデータ取り込み時に ANN インデックスを構築し、検索時の高速取得に最適化します。  

### 距離メトリクス

ベクトルの類似度は距離メトリクスによって測定されます。Weaviate は複数の距離メトリクスをサポートしています:

1. **コサイン類似度**: ベクトル間の角度のコサインを測定します（ほとんどのユースケースでのデフォルト）。  
2. **ユークリッド距離**: ベクトル間の直線距離を測定します。  
3. **ドット積**: ベクトルのドット積を計算します（特定の正規化済み埋め込みに有用）。  

## キーワード検索

### 転置インデックス

Weaviate のキーワード検索は転置インデックスに依存します。転置インデックスは、用語をそれを含むドキュメントにマッピングするデータ構造です。

1. **インデックス構築**: データ取り込み時に、Weaviate はテキストをトークンに分割し、それぞれのトークンを含むドキュメントにマッピングするインデックスを作成します。  
2. **トークナイゼーション**: 言語、ステミング、ストップワードなどを考慮しながらテキストを単語またはサブワードへ分割します。  
3. **ポスティングリスト**: 各用語に対して、転置インデックスはその用語を含むドキュメントのリストと、用語頻度などの追加情報を保持します。  

### BM25 アルゴリズム

Weaviate は、キーワード検索の結果をランク付けするために BM25F アルゴリズムを使用します。

1. **Term Frequency (TF)**: 単語がドキュメント内に出現する頻度を測定します。  
2. **Inverse Document Frequency (IDF)**: すべてのドキュメントにおける単語の希少性 / 一般性を測定します。  
3. **フィールド重み**: BM25F では、ドキュメント内のフィールドごとに異なる重みを設定できます。  
4. **スコアリング**: TF、IDF、フィールド重みを組み合わせて各ドキュメントの関連度スコアを算出します。  

## ハイブリッド検索

### フュージョン方式

Weaviate では、ベクトル検索とキーワード検索の結果を組み合わせるために 2 つのフュージョン方式を提供しています:

1. **Relative Score Fusion**:  
   - ベクトル類似度と BM25 スコアを共通スケールに正規化します。  
   - 正規化されたスコアを加重和で結合します。  
2. **Ranked Fusion**:  
   - ベクトル検索結果とキーワード検索結果における各オブジェクトの順位に基づいてスコアを割り当てます。  
   - 順位ベースのスコアを組み合わせて最終的な順序を生成します。  

### Alpha パラメーター

Alpha パラメーターは、ハイブリッド検索におけるベクトル検索とキーワード検索のバランスを制御します:

- Alpha = 0: 純粋なキーワード検索  
- Alpha = 1: 純粋なベクトル検索  
- 0 < Alpha < 1: 両者の加重組み合わせ  

## パフォーマンスに関する考慮事項

1. **インデックス作成**: 効率的なインデックス（ANN と転置の両方）を構築することは検索パフォーマンスに不可欠です。  
2. **シャーディング**: Weaviate は複数のシャードにデータを分散させることでスケーラビリティを向上できます。  
3. **キャッシュ**: 適切なキャッシュ戦略により、繰り返しまたは類似クエリの応答時間を大幅に短縮できます。  
4. **ハードウェア**: 特にベクトル演算において GPU アクセラレーションがパフォーマンスを向上させます。  
## 再ランキング

再ランキングは、より高度なモデルや別の基準を用いて初期検索結果の順序を並べ替えることで、検索の関連性を向上させる手法です。

### クロスエンコーダーモデル

1. ** Bi-Encoder と Cross-Encoder **: 初期の検索では効率性のために Bi-Encoder モデルがよく使用されますが、再ランキングでは精度向上のために Cross-Encoder モデルが一般的に使われます。  
2. ** アテンションメカニズム **: Cross-Encoder はクエリとドキュメントのペアを同時に処理するため、関連性をより細かく理解できます。  
3. ** 計算コストのトレードオフ **: Cross-Encoder は計算負荷が高いため、通常は最初に取得した結果の一部にのみ適用されます。  


## 関連性の最適化

検索の関連性は以下の要素によって影響を受ける可能性があります。

### ベクトル検索の品質

#### ベクトライザーモデルの選択

ベクトライザーモデルは、オブジェクトをベクトルへ変換する方法を決定します。

データのモダリティ (テキスト、画像、音声など) に適したモデルを選択してください。ドメイン特化型モデルの利用や、モデルの複雑さと性能要件のバランスも検討する必要があります。

Weaviate は ::model provider integrations:: と統合されています。

#### ベクトル化するフィールドの選定

セマンティック理解に最も寄与するフィールドを特定します。複数のフィールドを 1 つのベクトル埋め込みに結合することも検討してください。構造化データと非構造化データのどちらをベクトル化するかによる影響を評価します。

#### ANN インデックス設定

### キーワード検索

- インデックスプロパティの長さ、null プロパティなど  
- これらの設定が検索動作と利用可能なクエリに与える影響  
- k1 と b の値  

### ハイブリッド検索

- ハイブリッド融合方式  
- Alpha 値  

## 検索パフォーマンスとスケーラビリティ

- ベクトルインデックス設定とクエリ性能  
- 量子化とクエリ  
- 大規模データセットでの検索最適化ベストプラクティス  

## 検索拡張生成 (Retrieval Augmented Generation: RAG)

Retrieval Augmented Generation (RAG)、別名 生成検索 は、従来の検索機構と生成系 AI モデルを組み合わせ、取得した情報を基に新しいコンテンツを生成します。

### RAG アーキテクチャ

1. ** Retriever **: Weaviate の検索機能 ( ベクトル 、キーワード、ハイブリッド ) を用いて関連情報を取得します。  
2. ** Generator **: 取得した情報とユーザークエリを基に、大規模言語モデル (LLM) が回答を生成します。  
3. ** プロンプトエンジニアリング **: ユーザークエリと取得情報を組み合わせて効果的なプロンプトを作成し、LLM の出力を誘導します。  

### 言語モデルとの統合

1. ** API 接続 **: Weaviate は OpenAI、Cohere、Google などさまざまな LLM プロバイダーと統合できます。  
2. ** モデル選択 **: 性能、コスト、ユースケース要件などの要因に基づき、適切なモデルを選択します。  
3. ** トークン管理 **: トークン上限と切り詰めを適切に扱い、LLM API を効果的に利用します。  

### RAG ワークフロー

1. ** クエリ処理 **: ユーザークエリを解析し、検索パラメーターを決定します。  
2. ** 情報検索 **: Weaviate の検索機能を使用して関連ドキュメントやデータポイントを取得します。  
3. ** コンテキスト準備 **: 取得した情報を生成モデルのコンテキストとして整形します。  
4. ** 応答生成 **: クエリと準備したコンテキストを LLM に送り、回答を生成します。  
5. ** 後処理 **: 必要に応じて、生成された回答を整形または改善し、ユーザーに返します。  


## AI モデルと検索

### 概要

- 検索における AI モデルの役割 ( ベクトル検索、再ランキング、生成検索 など )  

### モデル選定ガイド

- 適切なモデルを選ぶ際の基準  
- 異なるモデルタイプ間のトレードオフ  

## 検索関連性とランキング

- Weaviate が結果の順序を決定する方法  
- 検索関連性を向上させるテクニック  

## 代表的なユースケース

- E-commerce 商品検索  
- コンテンツ推薦システム  
- セマンティック文書検索  
- 画像・マルチメディア検索  

## トラブルシューティングと一般的な落とし穴

- 検索実装でよく発生する問題の対処  
- 検索関連の問題を診断・解決するためのヒント