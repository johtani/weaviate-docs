---
title: Philosophy
sidebar_position: 2
image: og/docs/concepts.jpg
# tags: ['architecture']
---

## Weaviate のユーザー利用パターンに基づく設計

Weaviate のレプリケーション システムの設計原則は、ユーザーが Weaviate をどのように利用しているかに基づいています。Weaviate はサイト検索、レコメンデーション、知識抽出などの情報検索ユースケースを支えています。これらのユースケースには、以下の共通点があります。  
* 多くの場合 **非常に大規模** （数十億件のオブジェクトと ベクトル を含むデータセット）  
* 厳しいレイテンシ要件を伴う **大規模な並列利用** が発生することが多い（ p99 レイテンシが低い状態で高スループットが求められる）  
* バージョン アップグレードなどの計画メンテナンスや突発的な障害に対してもサービスが **高可用性** を維持することが不可欠  
* 一時的にデータが同期していなくても、**最終的に整合性が取れる** のであれば許容されることが多い  
* トランザクション データが存在するユースケースでは、Weaviate は強い整合性を備えたトランザクション データベースと併用されることがあります。Weaviate がプライマリ データベースとして使用される場合、データは通常トランザクション性を必要としません。  
* Weaviate のユーザーは NoSQL データベースを含むクラウドネイティブ技術の経験が豊富で、最終的に整合性が取れるシステムを正しく扱うためにアプリケーションをどのように設計すべきかを理解しています。  

上記の利用パターンを踏まえ、 [ CAP 定理 ](./index.md#cap-theorem) のトレードオフを考慮したうえで、Weaviate はクラスタ メタデータとデータ レプリケーションのために 2 つの異なるアーキテクチャを実装しています。  

1. **クラスタ メタデータ レプリケーション** は、選出されたリーダーがログベースの整合性操作を調整する [ Raft 合意アルゴリズム ](https://raft.github.io/) に基づいています。これにより、（少数の）ノードが障害を起こしてもクラスタ メタデータを変更できます。  

2. **データ レプリケーション** は、リーダーレス設計と調整可能な整合性に基づいています。そのため、フォロワー ノードへレプリケートする中央リーダーやプライマリ ノードは存在しません。Weaviate のデータ レプリケーション アーキテクチャは **可用性を整合性より優先** します。ただし、リクエストによってはより厳しい整合性要件が必要な場合があります。そのようなケース向けに、Weaviate では [ 読み取りおよび書き込み整合性の調整 ](./consistency.md) を提供しています。  

## リーダーレス アーキテクチャを採用する理由

Weaviate のレプリケーション アーキテクチャは、同様の目的を持つモダンなインターネット スケール データベースから着想を得ています。代表例として [ Apache Cassandra ](https://cassandra.apache.org/_/index.html) が挙げられます。Weaviate の [ レプリケーション アーキテクチャ ](./cluster-architecture.md) は Cassandra と多くの共通点があります。当然ながら、可用性とスループットの両立を図るためにリーダーレス パターンが選択されました。リーダー フル構成では、以下の 2 つの大きな欠点があります。  
1. すべての書き込みリクエストがリーダーを経由するため、リーダーが性能ボトルネックになる。  
2. リーダーが障害を起こした場合、新しいリーダーの選出が必要になり、そのプロセスは複雑かつコストが高く、一時的なサービス停止を招く可能性がある。  

リーダー フル システムの主な利点は、特定の整合性保証を提供しやすい点にあります。しかし前述の動機から、Weaviate は大規模ユースケース、リニア スケーリング、および可用性を、厳格な整合性よりも重視しています。  

## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>