---
title: クラスターアーキテクチャ
sidebar_position: 3
image: og/docs/concepts.jpg
# tags: ['architecture']
---


このページでは、Weaviate のレプリケーション設計におけるノードやクラスターがどのように動作するかを説明します。

Weaviate では、メタデータのレプリケーションとデータのレプリケーションが分離されています。メタデータには [Raft](https://raft.github.io/) コンセンサスアルゴリズムが、データにはリーダーレス設計による最終的な整合性モデルが採用されています。

## ノードディスカバリー

既定では、クラスター内の Weaviate ノードは [Hashicorp の Memberlist](https://github.com/hashicorp/memberlist) を介したゴシップライクなプロトコルでノード状態や障害シナリオを共有します。

特にクラスター運用時、Weaviate は Kubernetes での実行に最適化されています。[Weaviate Helm チャート](/deploy/installation-guides/k8s-installation.md#weaviate-helm-chart) では `StatefulSet` とヘッドレス `Service` を利用し、ノードディスカバリーを自動設定します。

<details>
  <summary>ノードディスカバリーの FQDN</summary>

:::caution `v1.25.15` で追加、`v1.30` で削除

これは実験的機能です。使用にはご注意ください。

:::

IP アドレスベースのノードディスカバリーが最適でない場合があります。その際は、`RAFT_ENABLE_FQDN_RESOLVER` と `RAFT_FQDN_RESOLVER_TLD` の [環境変数](/deploy/configuration/env-vars/index.md#multi-node-instances) を設定し、[完全修飾ドメイン名 (FQDN)](https://en.wikipedia.org/wiki/Fully_qualified_domain_name) ベースのノードディスカバリーを有効にできます。

この機能が有効な場合、Weaviate は FQDN リゾルバーを使用して、メタデータ（例: Raft）通信時にノード名からノード IP アドレスを解決します。

:::info FQDN: メタデータ変更のみ
この機能は Raft を用いたメタデータ変更時のみに使用され、データの読み書き操作には影響しません。
:::

#### FQDN ディスカバリーを使用するシナリオ例

IP アドレスが異なるクラスター間で再利用されると、一方のクラスターのノードが誤って別クラスターのノードを発見してしまう可能性があります。FQDN を利用すると、このような状況を解消できます。

また、サービス（Kubernetes など）を利用し、サービスの IP が実際のノード IP と異なり、プロキシ経由でノードへ接続する場合にも有用です。

#### FQDN ノードディスカバリー用環境変数

`RAFT_ENABLE_FQDN_RESOLVER` は Boolean フラグで、このフラグを `true` にすると FQDN リゾルバーが有効になります。`false` の場合、Weaviate は Memberlist ルックアップでノード名を IP アドレスへ解決します。デフォルト値は `false` です。

`RAFT_FQDN_RESOLVER_TLD` は文字列で、ノード ID を IP アドレスに解決する際 `[node-id].[tld]` 形式で `[tld]`（トップレベルドメイン）が付加されます。

この機能を使用するには、`RAFT_ENABLE_FQDN_RESOLVER` を `true` に設定してください。

</details>

## メタデータレプリケーション: Raft

:::info `v1.25` で追加
:::

Weaviate はメタデータのレプリケーションに [Raft コンセンサスアルゴリズム](https://raft.github.io/) を使用しており、Hashicorp の [raft ライブラリ](https://pkg.go.dev/github.com/hashicorp/raft) で実装されています。ここでのメタデータとは、コレクション定義やシャード／テナントの状態などです。

Raft はメタデータの変更がクラスター全体で一貫することを保証します。メタデータの変更はリーダーノードに転送され、リーダーは自身のログに変更を適用した後、フォロワーノードへレプリケートします。多数ノードが変更を承認すると、リーダーはログへのコミットを行い、その後フォロワーへ通知し各フォロワーが変更を適用します。

これにより、少数ノードの障害が発生してもメタデータ変更はクラスター全体で整合性を保ちます。

その結果、Weaviate クラスターにはメタデータ変更を担当するリーダーノードが存在します。リーダーは Raft によって選出され、メタデータ変更を調整します。

## データレプリケーション: リーダーレス

Weaviate はデータレプリケーションにリーダーレスアーキテクチャを採用しています。つまり、中央のリーダーやプライマリノードは存在せず、すべてのノードがクライアントからの書き込み・読み取りを受け付けます。これにより可用性が向上し、単一障害点がなくなります。リーダーレス方式は [Dynamo スタイル](https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf) とも呼ばれ、[Apache Cassandra](https://cassandra.apache.org) などの OSS でも採用されています。

Weaviate ではコーディネーションパターンを用いて、クライアントの読み書き要求を適切なノードへ中継します。リーダーベースのデータベースと異なり、コーディネーターノードは操作順序を強制しません。

以下の図は Weaviate におけるリーダーレスレプリケーション設計を示しています。1 つのコーディネーターノードがクライアントからのトラフィックを適切なレプリカへ導きます。このノード自体に特別な役割はなく、ロードバランサーからリクエストを受け取ったために選ばれただけです。同じデータへの次のリクエストは別のノードがコーディネートする場合もあります。

<p align="center"><img src="/img/docs/replication-architecture/replication-main-quorum.png" alt="Replication Architecture" width="75%"/></p>

リーダーレス設計の主な利点はフォールトトレランスの向上です。単一リーダー方式ではすべての書き込みがリーダーで処理されるため、リーダーがダウンすると書き込みが不可能になります。一方リーダーレスでは全ノードが書き込みを受け付けるため、マスターノード障害のリスクがありません。

高可用性の裏返しとして、リーダーレスデータベースは整合性が低下しやすい傾向があります。リーダーノードが存在しないため、ノード間でデータが一時的に古い（スタイル）状態になる場合があります。リーダーレスデータベースは最終的整合性を志向します。Weaviate の整合性は [チューニング可能](./consistency.md) ですが、その分可用性が犠牲になります。


## レプリケーションファクター

import RaftRFChangeWarning from '/_includes/1-25-replication-factor.mdx';

<RaftRFChangeWarning/>

Weaviate ではデータレプリケーションはコレクション単位で有効化・制御されます。そのため、コレクションごとに異なるレプリケーションファクターを設定できます。

レプリケーションファクター（RF または n）は、分散環境に保存されるデータコピー数を決定します。レプリケーションファクターが 1 の場合、各データエントリは 1 つしか存在せず、つまりレプリケーションがありません。レプリケーションファクターが 2 の場合、各データエントリが 2 つのノード（レプリカ）に保存されます。もちろん、レプリケーションファクターはノード数を超えられません。クラスター内のいずれのノードもコーディネーターノードとなり、クエリを正しいターゲットノードへ導けます。

パフォーマンスと耐障害性のバランスから、レプリケーションファクター 3 が一般的に使用されます。奇数ノード数が望ましいのは、コンフリクト解消が容易になるためです。3 ノード構成では、2 ノードでクォーラムに達するため、1 ノードの障害に耐えられます。一方 2 ノード構成では、全ノードが稼働していなければ合意形成できません。4 ノード構成ではクォーラムに 3 ノードが必要です。したがって、3 ノード構成は 2 ノードや 4 ノード構成より費用対効果の高い耐障害性を提供します。

<p align="center"><img src="/img/docs/replication-architecture/replication-factor.png" alt="Replication Factor" width="75%"/></p>

## 書き込み操作

書き込み時、クライアントのリクエストはクラスター内の任意のノードへ送信されます。最初にリクエストを受け取ったノードがコーディネーターノードに割り当てられます。コーディネーターノードはリクエストを所定数のレプリカノードへ送信し、クライアントへ結果を返します。つまりクラスター内のどのノードもコーディネーターノードになれます。クライアントが直接通信するのはこのコーディネーターノードのみです。結果を返す前に、コーディネーターノードは設定に応じた数の書き込み ACK を他ノードから受け取るまで待ちます。Weaviate が待機する ACK の数は [整合性設定](./consistency.md) により決まります。

**手順**  
1. クライアントがデータを任意のノードへ送信し、そのノードがコーディネーターノードとなる  
2. コーディネーターノードがデータをクラスター内の複数レプリカノードへ送信  
3. コーディネーターノードがクラスター内の x ノードから ACK を待機する。v1.18 以降、x は [設定可能](./consistency.md) で既定は `ALL`  
4. x 個の ACK を受信すると書き込み成功  

例として、クラスターサイズが 3 でレプリケーションファクターが 3 の場合、すべてのノードがデータを保持します。クライアントが新規データを送信すると、3 ノードすべてにレプリケートされます。

<p align="center"><img src="/img/docs/replication-architecture/replication-rf3-size3.png" alt="Replication Factor 3 with cluster size 3" width="75%"/></p>

クラスターサイズが 8、レプリケーションファクターが 3 の場合、書き込みは 8 ノードすべてではなく、そのデータのレプリカを保持する 3 ノードにのみ送信されます。コーディネーターノードがどのノードへ書き込むかを決定します。どのノードがどのコレクション（つまりシャード）を保持するかは Weaviate の設定で決まり、各ノード（および各コーディネーターノード）が認識しています。レプリケーション先は決定論的なため、すべてのノードがどのシャードにどのデータが配置されるかを把握しています。

<p align="center"><img src="/img/docs/replication-architecture/replication-rf3-size8.png" alt="Replication Factor 3 with cluster size 8" width="75%"/></p>

## 読み取り操作

読み取り操作もコーディネーターノードにより調整され、クエリをデータを保持する正しいノードへ送信します。1 つ以上のノードが古い（スタイル）データを保持している可能性があるため、読み取りクライアントは受け取ったデータから最新のものを選択してユーザーへ返します。

**手順**  
1. クライアントが Weaviate へクエリを送信し、最初に受け取ったノードがコーディネーターノードとなる  
2. コーディネーターノードがクエリをクラスター内の複数レプリカノードへ送信  
3. コーディネーターノードが x ノードからのレスポンスを待機する。*x は [設定可能](./consistency.md) で `ALL`、`QUORUM`、`ONE`（v1.18 以降、Get-Object-By-ID 型リクエストは v1.17 から調整可能）*  
4. コーディネーターノードがメタデータ（例: タイムスタンプ、ID、バージョン番号）を用いてデータの衝突を解決  
5. コーディネーターノードが最新データをクライアントへ返却  

クラスターサイズが 3、レプリケーションファクターも 3 の場合、すべてのノードがクエリに応答できます。整合性レベルに応じて、問い合わせるノード数が決まります。

クラスターサイズが 10、レプリケーションファクターが 3 の場合、そのデータ（コレクション）を保持する 3 ノードがクエリに応答し、コーディネーターノードが調整します。クライアントは x（整合性レベル） ノードから応答があるまで待機します。
## 質問およびフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>