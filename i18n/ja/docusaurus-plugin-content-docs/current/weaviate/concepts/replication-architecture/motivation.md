---
title: ユースケース（動機）
sidebar_position: 1
image: og/docs/concepts.jpg
# tags: ['architecture']
---

このページでは、Weaviate でレプリケーションを採用する動機となる 4 つのユースケースを紹介します。それぞれ目的が異なるため、必要となる設定も変わります。

## 高可用性（冗長性）

データベースの高可用性とは、サービスが中断されることなく継続して動作するよう設計されていることを意味します。つまり、障害やエラーが発生しても自動的に対処できる耐障害性が求められます。

これはレプリケーションによって解決できます。冗長ノードが他のノードの障害時にリクエストを処理できるからです。

Weaviate はクラスタメタデータの操作を重要視しており、データ操作とは別の方法で扱います。

Weaviate `v1.25` から、クラスタメタデータのレプリケーションに Raft コンセンサスアルゴリズムを使用しています。Raft はリーダーベースのコンセンサスアルゴリズムで、リーダーノードがクラスタメタデータの変更を担当します。Raft を用いることで、ノードの少数が障害を起こしてもクラスタメタデータの変更がクラスター全体で一貫して行われます。

Weaviate `v1.25` より前は、クラスタメタデータ操作にリーダーレス設計と 2 フェーズコミットを使用していました。これにより、コレクション定義の更新やテナント状態の更新といった操作にはすべてのノードが必要でした。そのため、一部のノードが一時的にダウンするとクラスタメタデータの操作が実行できませんでした。さらに、一度に実行できるクラスタメタデータ操作は 1 件のみでした。

データ操作に関しては、ノードがダウンしても分散データベース構成上で読み取りまたは書き込みクエリを継続できる場合があり、単一障害点を排除できます。ユーザーのクエリは自動的に（気付かないうちに）利用可能なレプリカノードへリダイレクトされます。

高可用性が求められるアプリケーションの例としては、緊急サービス、企業 IT システム、ソーシャルメディア、ウェブサイト検索などがあります。今日のユーザーは高可用性のアプリケーションに慣れているため、ダウンタイムはほとんど許容されません。例えばウェブサイト検索では、ノードがダウンしてもサービス（読み取りクエリ）が中断されてはいけません。この場合、書き込みが一時的にできなくても容認され、最悪でも検索結果が古いままになるだけで読み取りは可能です。

<p align="center"><img src="/img/docs/replication-architecture/replication-high-availability.png" alt="高可用性" width="75%"/></p>

高可用性を実現する設定例を以下に示します。  
1. 書き込み `ALL`、読み取り `ONE`  
   書き込みでは `ALL` ノードが応答する必要があるため高可用性はありません。読み取りではすべてのノードがダウンしても 1 つ残っていれば読み取り操作が可能です。  
2. 書き込み `QUORUM`、読み取り `QUORUM`（n/2+1）  
   少数のノードがダウンしても、大多数のノードが稼働していれば読み取りと書き込みの両方が可能です。  
3. 書き込み `ONE`、読み取り `ONE`  
   最も可用性の高い設定です。1 ノードを除くすべてがダウンしても読み取り・書き込みが可能です。ただし、この非常に高い可用性は低い整合性保証と引き換えになります。最終的整合性のため、一時的に古いデータが表示される点をアプリケーション側で許容する必要があります。

## （読み取り）スループットの向上

多くのユーザー向けにアプリケーションを構築しており Weaviate インスタンスへの読み取りリクエストが多数ある場合、データベース構成は高いスループットをサポートする必要があります。スループットは 1 秒あたりのクエリ数（QPS）で測定されます。データベースにサーバーノードを追加するとスループットも向上します。ノードが多いほど処理可能なユーザー（読み取り操作）が増えるため、Weaviate をレプリケーションするとスループットが向上します。

読み取りの整合性レベルを低く（例: `ONE`）設定すると、レプリケーションファクター（サーバーノード数）を増やすことでスループットが線形に伸びます。例えば読み取り整合性レベルが `ONE` の場合、1 ノードで 10,000 QPS を処理できるなら、3 レプリカノード構成では 30,000 QPS を処理できます。

<p align="center"><img src="/img/docs/replication-architecture/replication-increased-throughput.png" alt="スループットの向上" width="75%"/></p>

## 無停止アップグレード

レプリケーションを行わない場合、Weaviate インスタンスをアップデートする際にダウンタイムが発生します。単一ノードを停止し、アップデート後に再起動するまでサービスを提供できません。レプリケーションを利用するとローリングアップデートが可能になり、同時に利用不可となるノードは最大でも 1 つです。他のノードは引き続きトラフィックを処理できます。

例として、Weaviate のバージョンを v1.19 から v1.20 に更新する場合を考えます。レプリケーションがないと以下のようにダウンタイムが発生します。  
1. ノードがトラフィックを処理可能  
2. ノード停止、リクエスト不可  
3. ノードイメージを新バージョンへ置換  
4. ノード再起動  
5. ノードが準備完了するまで待機  
6. ノードが再びトラフィックを処理可能  

手順 2 から 6 までの間、Weaviate サーバーはリクエストを受信・応答できず、ユーザー体験が悪化します。

レプリケーション（例: レプリケーションファクター 3）を行っている場合、Weaviate のアップグレードはローリングアップデートで実施され、同時に利用不可になるノードは最大 1 つです。  
1. 3 ノードがトラフィックを処理可能  
2. ノード 1 を置換中、ノード 2・3 がトラフィックを処理  
3. ノード 2 を置換中、ノード 1・3 がトラフィックを処理  
4. ノード 3 を置換中、ノード 1・2 がトラフィックを処理  

<p align="center"><img src="/img/docs/replication-architecture/replication-zero-downtime.gif" alt="無停止アップグレード" width="75%"/></p>

## 地域的近接性

ユーザーが異なる地域（例: アイスランドとオーストラリアのように遠距離）に分散している場合、データベースサーバーとユーザー間の物理的距離により全ユーザーに低レイテンシーを保証することはできません。データベースサーバーは 1 つの地理的位置にしか配置できず、どこに置くかが課題となります。  
1. オプション 1 － 中間地点（例: インド）にクラスタを配置  
   アイスランドとインド間、オーストラリアとインド間でデータが移動するため、すべてのユーザーのレイテンシーが比較的高くなります。

    <p align="center"><img src="/img/docs/replication-architecture/replication-regional-proximity-1.png" alt="地理的中間にクラスタを配置" width="75%"/></p>

2. オプション 2 － あるユーザーグループの近く（例: アイスランド）にクラスタを配置  
   アイスランドのユーザーは非常に低レイテンシーですが、オーストラリアのユーザーは長距離通信のため比較的高レイテンシーになります。

   データクラスタを 2 つの地理的場所にレプリケートできる場合、別の選択肢が生まれます。これを Multi-Datacenter（Multi-DC）レプリケーションと呼びます。  
3. オプション 3 － アイスランドとオーストラリアの両方にサーバークラスタを置く Multi-DC レプリケーション  
   アイスランドとオーストラリアのユーザーはいずれもローカルクラスタからサービスを受けるため、低レイテンシーを得られます。

    <p align="center"><img src="/img/docs/replication-architecture/replication-regional-proximity-3.png" alt="Multi-DC レプリケーション" width="75%"/></p>

Multi-DC レプリケーションには、データが複数物理ロケーションで冗長化されるという追加の利点もあります。極めてまれにデータセンター全体がダウンした場合でも、別の場所からデータを提供できます。

:::note
Regional Proximity はレプリケーションの Multi-Datacenter 機能に依存します。関心がある方は [こちらで投票](https://github.com/weaviate/weaviate/issues/2436) してください。
:::

## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>