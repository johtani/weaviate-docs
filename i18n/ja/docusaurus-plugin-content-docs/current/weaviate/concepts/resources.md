Weaviate は大規模プロジェクトでも十分にスケールします。 1M オブジェクト未満の小規模プロジェクトではリソース計画は不要です。 中規模以上のプロジェクトでは、リソースから最高のパフォーマンスを引き出すための計画を立てることをおすすめします。 システムを設計する際は、CPU とメモリの管理に留意してください。 CPU とメモリが Weaviate インスタンスにとって主要なリソースです。 使用するモジュールによっては GPU が必要になる場合もあります。

## 利用可能リソースの制限

[環境変数](/deploy/configuration/env-vars/index.md) を設定して、Weaviate のリソース使用量を制御し、すべてのリソースを使い切らないようにできます。 使用可能な環境変数は次のとおりです。

- `LIMIT_RESOURCES`： `true` に設定すると、Weaviate は自動的にリソース使用量を制限します。 メモリ使用量を合計メモリの 80% に設定し、CPU コアは 1 つ残してすべて使用します。 `GOMEMLIMIT` の値を上書きしますが、`GOMAXPROCS` の設定は尊重します。

- `GOMEMLIMIT`： Go ランタイムのメモリ上限を設定します。 Weaviate に割り当てる総メモリのおよそ 10〜20% を目安に設定してください。 メモリ使用量がこの上限に近づくと、Garbage Collector の動作が積極的になります。

- `GOMAXPROCS`： 同時実行に使用する最大スレッド数を設定します。 設定されている場合、`LIMIT_RESOURCES` でもこの値は尊重され、Weaviate が使用する CPU コア数を厳密に指定できます。

これらの設定により、システムに合わせてリソース使用量を最適化しつつ、Weaviate のパフォーマンスを調整できます。

## CPU の役割

:::tip Rule of thumb
CPU はクエリとインポート速度に直接影響しますが、データセットサイズには影響しません。
:::

ベクトル検索は Weaviate の処理の中で最も CPU 集約的です。 クエリは CPU バウンドですが、インポートもインデックス作成でベクトル検索を行うため CPU バウンドになります。 Weaviate は HNSW（Hierarchical Navigable Small World）アルゴリズムを用いてベクトルをインデックス化します。 主要なユースケースに合わせてパフォーマンスを最大化するために、コレクションごとに [HNSW インデックス]("../config-refs/schema/vector-index.md") をチューニングできます。

複数の CPU を効率的に使用するには、コレクションに複数のシャードを作成してください。 最速でインポートするには、単一ノードでも複数シャードを作成します。

各 insert や search は単一スレッドで実行されます。 しかし複数の search もしくは insert を同時に行うと、Weaviate は複数スレッドを利用できます。 [バッチインポート](/weaviate/manage-objects/import) は複数スレッドでデータを並列処理します。

### CPU を追加すべきタイミング

- インポート中に CPU 使用率が高い場合は、CPU を追加してインポート速度を向上させます。
- 検索スループットが制限されている場合は、CPU を追加して 1 秒あたりのクエリ数を増やします。

## メモリの役割

:::tip Rule of thumb
メモリはサポートできるデータセットの最大サイズを決定します。 メモリはクエリ速度には直接影響しません。
:::

HNSW インデックスはメモリ上に保持する必要があります。 必要なメモリ量はデータセットサイズに直接比例します。 データセットサイズと現在のクエリ負荷には相関がありません。 [`product quantization (PQ)`](/weaviate/concepts/vector-quantization#product-quantization) を使用すると、ベクトルを圧縮してメモリに保持できるベクトル数を増やせます。

Weaviate では、予期しない Out-of-Memory（「OOM」）を防ぐために、メモリに保持するベクトル数の上限を設定できます。 既定値はコレクションごとに 1 兆（`1e12`）オブジェクトです。 オブジェクト数を調整する場合は、インデックス設定の [`vectorCacheMaxObjects`](../config-refs/schema/vector-index.md) の値を更新してください。

Weaviate はディスクに保存されたデータに対して [メモリマップトファイル](https://en.wikipedia.org/wiki/Memory-mapped_file) も使用します。 メモリマップトファイルは効率的ですが、ディスクアクセスはメモリ内アクセスよりはるかに遅くなります。

### メモリ使用量を左右する要因

HNSW ベクトルインデックスがメモリ使用量の主因です。 次の要素が Weaviate のメモリ使用量に影響します。

- **オブジェクトベクトルの総数**  
  重要なのはベクトルの数であり、元のオブジェクトのサイズではありません。 メモリに保持されるのはベクトルのみで、元のテキストやその他データのサイズは制限要因になりません。

- **`maxConnections` HNSW インデックス設定**  
  メモリ上の各オブジェクトはレイヤーごとに最大 [`maxConnections`](../config-refs/schema/vector-index.md) 個の接続を持ちます。 各接続は 8〜10B のメモリを使用します。 ベースレイヤーでは `2 * maxConnections` が使用される点に注意してください。

### 計算例

:::note
以下の計算は、すべてのベクトルをメモリに保持する場合を想定しています。 メモリとディスクを組み合わせたハイブリッド方式については、後述の [Vector Cache](#vector-cache) を参照してください。
:::

メモリ要件を見積もる際は、次の経験則を使用します。

`Memory usage = 2 * (the memory footprint of all vectors)`

たとえば、1M 件の 384 次元ベクトル（型 `float32`）を持つモデルを考えます。

- 1 本のベクトルのメモリ要件： `384 * 4 B = 1536 B`
- 1M オブジェクトのメモリ要件： `1e6 * 1536 B = 1.5G B`

経験則によりメモリ要件を倍にします。 したがって、1M 件の 384 次元 `float32` ベクトルの合計メモリ要件は `2 * 1e6 * 1536 B = 3 GB` です。

より正確な計算を行う場合は、基本要件を 2 倍する代わりに [`maxConnections`](../config-refs/schema/vector-index.md) の係数を含めます。

たとえば、`maxConnections` が 64 でその他の値が同じ場合、より正確なメモリ見積りは  
`1e6 * (1536B + (64 * 10)) = 2.2 GB` です。

`maxConnections` を含む見積りは経験則より小さくなります。 しかし、`maxConnections` を用いた見積りにはガーベジコレクションのオーバーヘッドが含まれていません。 ガーベジコレクションのオーバーヘッドについては次節で説明します。

## ガーベジコレクションの影響

Weaviate は Go で記述されており、Go はガーベジコレクションを採用しています。 そのため、不要になったメモリが直ちに再利用可能になるわけではありません。 アプリケーションは非同期で動作するガーベジコレクタがメモリを解放するのを待つ必要があります。 これにはメモリ使用量に対して 2 つの明確な影響があります。

- [ガーベジコレクタによるメモリオーバーヘッド](#memory-overhead-for-the-garbage-collector)
- [ガーベジコレクションによる Out-of-Memory 問題](#out-of-memory-issues-due-to-garbage-collection)

### ガーベジコレクタによるメモリオーバーヘッド
`maxConnections` を含むメモリ計算は、システムが安定した状態（rest）を表しています。 しかし Weaviate がベクトルをインポートしている間は追加のメモリが割り当てられ、最終的にはガーベジコレクタによって解放されます。 ガーベジコレクションが非同期であるため、この追加メモリも考慮する必要があります。 経験則の式はガーベジコレクションを考慮しています。

### ガーベジコレクションによる Out-of-Memory 問題
まれに、特に大規模マシンで非常に高速なインポートを行う場合、Weaviate がガーベジコレクタより速くメモリを確保してしまうことがあります。 その結果、システムカーネルが `out of memory kill (OOM-Kill)` を発生させることがあります。 これは既知の課題であり、Weaviate では対応を進めています。

### データインポート
インポート中の OOM を回避するには、`LIMIT_RESOURCES` を `True` に設定するか、`GOMEMLIMIT` 環境変数を設定してください。 詳細は [Environment variables](/deploy/configuration/env-vars/index.md) を参照してください。

## メモリ使用量を削減する戦略

Weaviate のメモリ使用量を削減するには、次の方法が役立ちます。

- **ベクトル圧縮を使用する**  
  直積量子化 (PQ) はベクトルサイズを削減する手法です。 ベクトル圧縮はリコール性能に影響するため、本番環境で使用する前にデータセットでテストすることを推奨します。  
  詳細は [Product Quantization](/weaviate/concepts/vector-quantization) を参照してください。  
  PQ の設定方法は [Compression](../configuration/compression/pq-compression.md) を参照してください。

- **ベクトルの次元数を減らす**  
  メモリサイズを削減する最も効果的な方法は、ベクトル当たりの次元数を減らすことです。 高次元ベクトルを使用している場合は、より少ない次元を使用するモデルを検討してください。 たとえば 384 次元モデルは 1536 次元モデルより大幅に少ないメモリで済みます。

- **HNSW インデックス設定の [`maxConnections`](../config-refs/schema/vector-index.md) を減らす**  
  メモリ上の各オブジェクトは最大 `maxConnections` 個の接続を持ち、各接続は 8〜10B のメモリを消費します。 メモリフットプリントを削減するには `maxConnections` を小さくします。  
  ただし `maxConnections` を減らすと HNSW のリコール性能が低下します。 これを緩和するには `efConstruction` と `ef` のいずれか、または両方を増やしてください。  
  - `efConstruction` を増やすとインポート時間が長くなりますが、クエリ時間には影響しません。  
  - `ef` を増やすとクエリ時間が長くなりますが、インポート時間には影響しません。

- **ベクトルキャッシュを全ベクトルより小さく設定する（推奨しません）**  
  この方法は後述の [Vector Cache](#vector-cache) で説明します。 パフォーマンスに大きく影響するため、特定かつ限定的な状況でのみ推奨されます。

## Vector Cache

検索とインポートの最適なパフォーマンスを得るには、インポート済みのすべてのベクトルをメモリに保持する必要があります。 ベクトルキャッシュのサイズは、コレクション定義の [`vectorCacheMaxObjects`](../config-refs/schema/vector-index.md) パラメータで指定します。 新しいコレクションを作成する際の既定値は 1 兆（`1e12`）オブジェクトです。

`vectorCacheMaxObjects` を小さくすることは可能ですが、ディスクからベクトルを読み込む場合、メモリからの読み込みに比べて桁違いに遅くなります。 `vectorCacheMaxObjects` を減らすのは慎重に行い、最後の手段としてください。

一般的な推奨事項は次のとおりです。
- インポート時には、`vectorCacheMaxObjects` をすべてのベクトルをメモリに保持できる値に設定してください。 各インポートで複数回の検索が行われます。 キャッシュにすべてのベクトルを保持できない場合、インポート性能は大幅に低下します。

- インポート後、主なワークロードがクエリである場合は、データセット全体より小さいキャッシュサイズを試してください。  
  キャッシュに存在しないベクトルは、空きがある限りキャッシュに追加されます。 キャッシュがいっぱいになると、Weaviate はキャッシュを丸ごと削除します。 その後のベクトルは最初のアクセス時にディスクから読み込まれ、その後キャッシュに保持されます。 キャッシュが再びいっぱいになると同じ手順が繰り返されます。 大規模データセットで、多くのユーザーが特定のサブセットのベクトルのみをクエリする場合、キャッシュは非常に有効です。 この場合、大多数のユーザーにはキャッシュから応答し、「例外的」クエリのみでディスク読み込みが発生します。
### Weaviate マシンまたはクラスターのメモリ増設のタイミング

以下の場合はメモリの追加を検討してください:  
- より大きなデータセットをインポートしたいとき (こちらの方が一般的)。  
- 正確なルックアップがディスクに依存しており、メモリを増設することでページキャッシュが向上するとき (こちらはまれ)。

## Weaviate における GPU の役割

Weaviate Database 自体は GPU を使用しません。  
しかし、`text2vec-transformers`、`qna-transformers`、`ner-transformers` など、Weaviate がモジュールとして提供する一部のモデルは GPU での実行を想定しています。これらのモジュールは独立したコンテナ内で動作するため、モジュールのコンテナを GPU 対応ハードウェア上で実行しつつ、Weaviate Database は低コストの CPU のみのハードウェアで実行することができます。

## ディスク: SSD とスピニングディスク

Weaviate は Solid-State Disks (SSD) で最適化されています。ただし、スピニングハードディスクもパフォーマンスが低下するものの使用可能です。

## ファイルシステム

最適なパフォーマンスと信頼性を確保するために、Weaviate の永続ボリューム ([`PERSISTENCE_DATA_PATH`](/deploy/configuration/env-vars/index.md)) には `NFS` などのファイルシステムの使用を避けてください。  

代わりに、`Ext4` や `XFS` のようなファイルシステムを SAN ストレージ (例: `EBS`) と組み合わせて使用し、最高のパフォーマンスを実現してください。

## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>