---
title: Storage
sidebar_position: 18
image: og/docs/concepts.jpg
# tags: ['architecture', 'storage']
---

Weaviate は永続性とフォールトトレラント性を備えたデータベースです。ここでは、オブジェクトと ベクトル が Weaviate 内でどのように保存され、インポート時にどのように 転置インデックス が作成されるかを概観します。

このページで取り上げるコンポーネントは、Weaviate が次のような独自機能を提供するうえで役立っています。

* 各書き込み操作は直ちに永続化され、アプリケーションやシステムのクラッシュにも耐性があります。  
* ベクトル 検索クエリでは、Weaviate は参照 (ID など) だけでなくオブジェクト全体 (他のデータベースでは「ドキュメント」と呼ばれることもあります) を返します。  
* 構造化検索と ベクトル 検索を組み合わせる場合、フィルターは ベクトル 検索の前に適用されます。そのため、後段でフィルターする場合と異なり、常に指定した件数の結果を受け取れます。  
* オブジェクトとその ベクトル は、読み取り中でも自由に更新・削除できます。  

## 論理ストレージ単位: インデックス、シャード、ストア

ユーザー定義スキーマ内の各クラスは、内部的にインデックスを生成します。インデックスは 1 つ以上のシャードで構成されるラッパー型です。インデックス内のシャードは自己完結したストレージ単位であり、複数のシャードを使用すると、負荷を複数サーバーノードへ自動的に分散できます。

### シャードの構成要素

各シャードには 3 つの主要コンポーネントがあります。

* オブジェクトストア (本質的にはキー・バリュー・ストア)  
* [転置インデックス](https://en.wikipedia.org/wiki/Inverted_index)  
* ベクトル インデックスストア (プラガブルで、現在は [HNSW のカスタム実装](/weaviate/config-refs/schema/vector-index#hnsw-indexes))  

#### オブジェクトストアと転置インデックスストア

バージョン `v1.5.0` 以降、オブジェクトストアと転置インデックスストアは [LSM-Tree アプローチ](https://en.wikipedia.org/wiki/Log-structured_merge-tree) を採用しています。これにより、データはメモリ速度で取り込まれ、設定したしきい値に達すると Weaviate は (ソート済みの) メムテーブル全体をディスクセグメントへ書き込みます。読み取り要求が来ると、Weaviate はまずメムテーブルで該当オブジェクトの最新バージョンを確認し、存在しなければ最新セグメントから順に過去のセグメントを確認します。不要なセグメントを調べるのを避けるために [Bloom フィルター](https://en.wikipedia.org/wiki/Bloom_filter) を使用します。

Weaviate は定期的に古い小さなセグメントをマージして大きなセグメントを作成します。セグメントは既にソートされているため、この処理は比較的低コストで、バックグラウンドで継続的に実行されます。セグメントが少なく大きいほど検索が効率化されます。転置インデックスではデータが置き換えられることはまれで、大抵は追加されます。マージを行うことで、過去のすべてのセグメントを調べて結果を集約する代わりに、1 つ (またはいくつか) の大きなセグメントを参照して関連オブジェクトポインタを即座に取得できます。また、削除や更新によって古くなったオブジェクトの旧バージョンもセグメント単位で削除されます。

考慮事項

オブジェクトストレージと転置インデックスストレージは LSM アルゴリズムを実装しており、セグメンテーションを使用します。一方、ベクトル インデックスは異なるストレージアルゴリズムを採用し、セグメンテーションを使用しません。

`v1.5.0` より前の Weaviate バージョンは B+Tree ストレージ機構を使用していました。LSM 方式は高速で、計算量は一定時間 (constant time) となり、書き込み性能が向上しています。

Weaviate の LSM ストアの詳細は、[Go パッケージリポジトリ](https://pkg.go.dev/github.com/weaviate/weaviate/adapters/repos/db/lsmkv) の LSM ライブラリドキュメントをご覧ください。

#### HNSW ベクトルインデックスストレージ

各シャードには、オブジェクトストアおよび転置インデックスストアに対応する ベクトル インデックスが含まれます。ベクトル ストアは他のストアから独立しており、セグメンテーションを管理する必要がありません。

ベクトル インデックスをオブジェクトストレージと同一シャード内にまとめることで、各シャードが自己完結した単位となり、それぞれが所有データへのリクエストを独立して処理できます。また、ベクトル インデックスをストア内部ではなく横に配置することで、セグメント化された ベクトル インデックスの欠点を回避しています。

さらに、Write-Ahead-Logging と HNSW スナップショットを組み合わせることで、永続化と起動時の読み込みが最適化されています。詳細は [永続性とクラッシュ復旧](#persistence-and-crash-recovery) セクションをご覧ください。

### シャード構成要素の最適化

Weaviate のストレージ機構は、構造化データ/オブジェクトデータに対してセグメンテーションを使用します。セグメントはマージが低コストであり、未マージのセグメントも Bloom フィルターのおかげで効率的に探索できるため、取り込み速度が高く時間経過による劣化がありません。

Weaviate はシャード内で ベクトル インデックスを可能な限り大きく保ちます。HNSW インデックスは効率的にマージできないため、小さなインデックスを多数順次検索するより、単一の大きなインデックスを検索するほうが効率的です。

CPU を効率的に利用するには、コレクションに複数のシャードを作成してください。最速のインポートを行うには、単一ノード上でも複数のシャードを作成することを推奨します。

### 遅延シャード読み込み

:::info Added in `v1.23`
:::

Weaviate 起動時には、デプロイ内のすべてのシャードからデータを読み込みます。この処理には時間がかかる場合があります。`v1.23` 以前では、すべてのシャードが読み込まれるまでクエリを実行できませんでした。各テナントがシャードであるため、マルチテナント環境では再起動後の可用性が低下することがあります。

遅延シャード読み込みを使うと、より早くデータを扱い始められます。再起動後、シャードはバックグラウンドで読み込まれます。クエリ対象のシャードが既に読み込まれていれば、より早く結果を取得できます。まだ読み込まれていない場合、Weaviate はそのシャードの読み込みを優先し、準備が整い次第レスポンスを返します。

遅延シャード読み込みを有効にするには、システム構成ファイルで `DISABLE_LAZY_LOAD_SHARDS` 環境変数を `false` に設定してください。

:::caution 単一テナントコレクションでは遅延シャード読み込みを無効化してください
単一テナントのコレクションでは、遅延読み込みによりインポート操作が遅くなったり部分的に失敗したりする可能性があります。このようなシナリオでは遅延シャード読み込みを無効にすることを推奨します。
:::

## 永続性とクラッシュ復旧

### Write-Ahead-Log

オブジェクトストアと転置インデックスストアに使用される LSM ストア、および HNSW ベクトル インデックスストアは、取り込み処理のどこかでメモリを使用します。クラッシュ時のデータ損失を防ぐため、各操作は **[Write-Ahead-Log (WAL)](https://martinfowler.com/articles/patterns-of-distributed-systems/wal.html)** (コミットログとも呼ばれます) にも書き込まれます。WAL は追記専用ファイルで、書き込みが非常に高速なため取り込みのボトルネックになりにくい方式です。

Weaviate が取り込みリクエストに対して成功ステータスを返す時点で、WAL エントリは必ず生成されています。たとえばディスク容量が不足して WAL エントリを生成できない場合、Weaviate は挿入や更新リクエストにエラーで応答します。

LSM ストアは正常終了時にセグメントのフラッシュを試みます。フラッシュが成功した場合のみ、WAL は「完了」とマークされます。予期しないクラッシュが発生し、Weaviate が「未完了」の WAL を検出した場合にはリカバリを行います。このリカバリ処理では、WAL を基に新しいセグメントをフラッシュして完了マークを付けます。その結果、将来の再起動時にはこの WAL からのリカバリが不要になります。

HNSW ベクトル インデックスにとっても WAL は災害復旧および最新変更の永続化に不可欠です。HNSW インデックスの構築コストは、新規オブジェクトの配置場所と近傍リンクの計算にあります。WAL にはそれら計算結果のみが記録されます。

インデックス全体の状態は、これら WAL エントリをリプレイすることで再構築できます。

数千万〜数億件規模の非常に大きなインデックスでは、この処理に時間がかかる場合があります。大規模インデックスで起動時間を短縮したい場合は **[HNSW スナップショット](../configuration/hnsw-snapshots.md)** 機能をご利用ください。

### HNSW スナップショット

:::info Added in `v1.31`
:::

非常に大きな HNSW ベクトル インデックスでは、HNSW スナップショットにより起動時間を大幅に短縮できます。

スナップショットは HNSW インデックスのある時点での状態を表します。起動時に有効なスナップショットが存在する場合、まずスナップショットがメモリへロードされます。これにより、スナップショット取得後の変更分だけを WAL からリプレイすればよいので、処理すべき WAL エントリ数が減り、起動時間が大幅に短縮されます。

何らかの理由でスナップショットをロードできない場合は安全に削除され、Weaviate は従来どおりコミットログ全体を最初から読み込む方式にフォールバックします。

スナップショットは起動時および時間経過やコミットログの変化量に応じて定期的に作成できます。

起動時にコミットログに変更がある場合、Weaviate は新しいスナップショットの作成を試みます。変更がなければ既存のスナップショットが読み込まれます。

設定した時間間隔が経過し、十分な新規コミットが存在する場合にもスナップショットが作成されます。これはコミットログの結合・圧縮を行うバックグラウンドプロセスによって処理されるため、その間に使用されるコミットログは不変であり安定性が保たれます。

各新規 HNSW スナップショットは、前回のスナップショットとその後の新しい (デルタ) コミットログを基に作成されます。

最新のスナップショットがあっても、その後に少なくとも 1 つのコミットログファイルをロードする必要がある点に注意してください。

WAL は依然としてすべての変更を即座に永続化し、受理済み書き込みが確実に耐久性を持つようにしています。時間が経つと、最後のスナップショット以降の操作に関して冗長な情報が WAL に蓄積されます。バックグラウンドプロセスが継続的に新しい WAL ファイルを圧縮し、冗長情報を除去します。これにスナップショット作成を組み合わせることで、ディスク使用量を抑え、起動時間を高速に保ちます。

この機能の設定方法については **[HNSW スナップショットの設定](../configuration/hnsw-snapshots.md)** をご覧ください。

`v1.31` 現在、HNSW スナップショットはデフォルトで無効になっています。

## まとめ

このページでは Weaviate のストレージ機構について紹介しました。すべての書き込みが即時に永続化される仕組みと、データセットをスケールさせるために Weaviate が採用しているパターンを説明しました。構造化データに対してはセグメンテーションを用いて書き込み時間を一定に保ち、HNSW ベクトル インデックスに対してはセグメンテーションを避けて検索時間を効率化しています。
## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>