---
title: Horizontal Scaling
sidebar_position: 30
image: og/docs/concepts.jpg
# tags: ['architecture', 'horizontal scaling', 'cluster', 'replication', 'sharding']
---

Weaviate は、複数ノードのクラスタ上で実行することで水平スケールが可能です。このセクションでは、Weaviate をスケールするさまざまな方法、スケール時に考慮すべき要素、および水平スケールに関連する Weaviate のアーキテクチャについて説明します。

## Weaviate をスケールする動機
一般的に、水平スケールには少なくとも 3 つの明確な動機があり、それぞれ異なるセットアップにつながります。

### 動機 1: 最大データセットサイズ
[HNSW グラフのメモリフットプリント](./resources.md#the-role-of-memory) により、データセットを複数のサーバー（「ノード」）に分散したい場合があります。このセットアップでは、1 つのクラスインデックスが複数のシャードで構成され、シャードがサーバー間に分散されます。

Weaviate は、インポート時とクエリ時に必要なオーケストレーションを完全に自動で実行します。必要な調整は、希望するシャード数を指定することだけです。複数シャードを使用する際のトレードオフについては、[シャーディングとレプリケーション](#シャーディングとレプリケーション) を参照してください。

**解決策: クラスタ内の複数ノードにシャーディング**

:::note
クラスタ全体でのシャーディング機能は Weaviate `v1.8.0` で追加されました。
:::

### 動機 2: 高いクエリスループット
単一の Weaviate ノードで処理できる以上のクエリを受け取る場合、追加の Weaviate ノードを導入してユーザーのクエリに応答できるようにすることが望ましいです。

複数ノードにシャーディングする代わりに、同じデータを複数ノードにレプリケートできます。このプロセスも完全に自動化されており、必要なのは希望するレプリケーションファクターを指定することだけです。シャーディングとレプリケーションを組み合わせることも可能です。

**解決策: クラスタ内の複数ノードにクラスをレプリケート**

### 動機 3: 高可用性
Weaviate でクリティカルな負荷を処理する場合、ノードが完全に故障してもクエリを提供し続けたいことがあります。故障はソフトウェアや OS レベルのクラッシュ、あるいはハードウェア障害が原因となり得ます。予期しないクラッシュ以外にも、ゼロダウンタイムアップデートやその他メンテナンス作業を許容できる構成が望ましいです。

高可用性を実現するには、クラスを複数ノード間でレプリケートする必要があります。

**解決策: クラスタ内の複数ノードにクラスをレプリケート**

## シャーディングとレプリケーション
前述の動機により、クラスを複数ノードにシャーディングする場合とレプリケートする場合、またはその両方を行う場合があります。このセクションでは、シャーディングおよび／またはレプリケーション構成の影響を説明します。

:::note
以下のシナリオでは、シャーディング数またはレプリケーションファクターを増やす際にクラスタサイズも同様に調整されることを前提としています。クラスタ内のノード数よりシャード数やレプリケーションファクターが少ない場合、以下の利点は適用されなくなります。*
:::

### シャーディング数を増やす利点
* より大きなデータセットを扱える
* インポートを高速化

複数の CPU を効率的に使用するには、コレクションに複数のシャードを作成します。最速のインポートを行うには、単一ノードでも複数シャードを作成してください。

### シャーディング数を増やす欠点
* シャード化ノードを追加してもクエリスループットは向上しない

### レプリケーション数を増やす利点
* システムが高可用になる
* レプリケーションを増やすとクエリスループットがほぼ線形に向上

### レプリケーション数を増やす欠点
* レプリケートしたノードを追加してもインポート速度は向上しない

## シャーディングキー（パーティショニングキー）
`v1.8.0` 以降、シャーディングキーは常にオブジェクトの UUID です。シャーディングアルゴリズムは 64 ビット Murmur-3 ハッシュです。将来的には他のプロパティやアルゴリズムが追加される可能性があります。

## リシャーディング
Weaviate は仮想シャードシステムを使用してオブジェクトをシャードに割り当てます。これによりリシャーディング時のデータ移動が最小限に抑えられます。ただし、HNSW インデックスの存在からリシャーディングは依然として高コストであり、使用は稀にすべきです。リシャーディングのコストは、移動対象データ量に関して初回インポートと概ね同等です。

例 — 次のシナリオを想定します。クラスが 4 シャードで構成され、全データのインポートに 60 分かかるとします。シャード数を 5 に変更すると、各シャードは約 20% のデータを新しいシャードに移動します。これはデータセットの 20% のインポートに相当するため、所要時間は約 12 分と見積もられます。

## ノードディスカバリー
デフォルトでは、クラスタ内の Weaviate ノードは [Hashicorp の Memberlist](https://github.com/hashicorp/memberlist) を使用したゴシップライクなプロトコルでノード状態や障害シナリオを通信します。

Weaviate は、とくにクラスタとして実行する場合、Kubernetes 上での運用に最適化されています。[Weaviate Helm チャート](/deploy/installation-guides/k8s-installation.md#weaviate-helm-chart) は `StatefulSet` とヘッドレス `Service` を利用し、ノードディスカバリーを自動設定します。必要なのは希望するノード数を指定するだけです。

<details>
  <summary>ノードディスカバリーのための FQDN</summary>

:::caution `v1.25.15` で追加され `v1.30` で削除
これは実験的機能でした。利用の際はご注意ください。
:::

IP アドレスベースのノードディスカバリーが最適でない場合があります。そのようなケースでは、`RAFT_ENABLE_FQDN_RESOLVER` と `RAFT_FQDN_RESOLVER_TLD` [環境変数](/deploy/configuration/env-vars/index.md#multi-node-instances) を設定して、完全修飾ドメイン名（FQDN）ベースのノードディスカバリーを有効にできます。

この機能を有効にすると、Weaviate は FQDN リゾルバーを使用してノード名をノード IP アドレスに解決し、メタデータ（例: Raft）通信を行います。

:::info FQDN: メタデータ変更のみに使用
この機能は [Raft をコンセンサスメカニズムとして使用する](./replication-architecture/cluster-architecture.md#metadata-replication-raft) メタデータ変更にのみ適用されます。データの読み書きには影響しません。
:::

#### FQDN をノードディスカバリーに使用する例
IP アドレスが異なるクラスタ間で再利用される場合、一方のクラスタのノードが他方のクラスタのノードを誤って検出してしまうことがあります。FQDN を使うことでこの問題を回避できます。

また、サービス（例: Kubernetes）でサービスの IP が実際のノード IP と異なりプロキシされる場合にも有用です。

#### FQDN ノードディスカバリー用の環境変数
`RAFT_ENABLE_FQDN_RESOLVER` は Boolean フラグで、FQDN リゾルバーを有効にします。`true` にすると、Weaviate は FQDN リゾルバーを使用してノード名を IP アドレスに解決します。`false` の場合、Memberlist ルックアップを使用します。デフォルトは `false` です。

`RAFT_FQDN_RESOLVER_TLD` は文字列で、ノード ID を IP アドレスに解決する際に `[node-id].[tld]` 形式で `[tld]` を付加します。

この機能を利用するには、`RAFT_ENABLE_FQDN_RESOLVER` を `true` に設定してください。

</details>

## シャードおよびレプリケーションシャードのノードアフィニティ
Weaviate は、最も空きディスク容量が多いノードを選択しようとします。

これは新しいクラスを作成する場合にのみ適用され、既存クラスにデータを追加する場合には適用されません。

<details>
  <summary>Pre-<code>v1.18.1</code> の挙動</summary>

`v1.8.0` 〜 `v1.18.0` では、特定のシャードまたはレプリケーションシャードのノードアフィニティを指定できませんでした。

シャードは「稼働中」ノードに対して、ランダムに選ばれたノードからラウンドロビン方式で割り当てられていました。

</details>

## 一貫性と現在の制限

* `v1.25.0` 以降、Weaviate は選出されたリーダーによって調整されるログベースのアルゴリズムである Raft コンセンサスアルゴリズムを採用しました。これにより、スキーマの同時変更がサポートされるという追加のメリットがあります。<br/>Kubernetes をご利用の場合は、アップグレード前に [`1.25 移行ガイド`](/deploy/migration/weaviate-1-25.md) をご覧ください。アップグレードするには、既存の StatefulSet を削除する必要があります。
* `v1.8.0` 以降、クラスタ全体にスキーマ変更をブロードキャストするプロセスでは 2 フェーズトランザクション形式が使用されていますが、現時点ではトランザクションの存続期間中に発生するノード障害には対応できません。
* `v1.8.0` 以降、クラスタの動的スケーリングはまだ完全にはサポートされていません。既存のクラスタに新しいノードを追加することは可能ですが、シャードの所有権には影響しません。データが存在する場合、既存ノードを削除することはまだできません。ノードを削除する前にシャードが他のノードへ移動されないためです。

## 質問とフィードバック

import DocsFeedback from '/_includes/docs-feedback.mdx';

<DocsFeedback/>